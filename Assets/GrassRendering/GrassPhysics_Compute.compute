// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpdatePhysics
#include "TexturePackingUtils.cginc"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWStructuredBuffer<float4> imgBuffer;

float trampleCutoff;
float springiness;
float2 tramplePos;
float2 moveDir;
float width;
float height;


const float PI = 3.14159265f;

[numthreads(8, 8, 1)]
void UpdatePhysics(uint3 id : SV_DispatchThreadID)
{
    float2 trample;

	// Get the current color from the buffer
	float4 currentColor = imgBuffer[width * id.x + id.y];
    
    // Vector from the trample point to the pixel.
    float2 deltaPos = float2(tramplePos.x, tramplePos.y) - float2(id.x / width, id.y / height);

    // Cut off all values outside the trampleCutoff range.
    float shouldBeTramepled = step(length(deltaPos), trampleCutoff);

    // Smooth out the trample amount within the trampleCutoff range.  
    float distanceFactor = 1 - smoothstep(0, trampleCutoff, length(deltaPos));
    
    // Cut off all values behind the trampler (grass behind should not bend backwards).
    float directionFactor = step(0, dot(deltaPos, normalize(moveDir)));

    // Sum up the trample amount for the position.
    trample = normalize(deltaPos);
    trample *= directionFactor;
    trample *= shouldBeTramepled;
    trample *= distanceFactor;
    
	// Update the value from the buffer
    currentColor = float4(clamp(currentColor.x + trample.x, -1, 1), sin(clamp(currentColor.y - length(trample), -1, 1)), clamp(currentColor.z + trample.y, -1, 1), 0);
    currentColor /= (1.0 + springiness);
    
    // Pack the values and set them in the texture.
    float4 currentColorPacked = PackFloat4(currentColor);

	// Write the value to the result texture
    Result[id.xy] = currentColorPacked;

	// Save it in the buffer again
    imgBuffer[width * id.x + id.y] = currentColor;
    
}

