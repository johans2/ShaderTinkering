// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpdatePhysics
#include "TexturePackingUtils.cginc"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWStructuredBuffer<float4> imgBuffer;

float trampleSmooth;
float trampleCutoff;
float4 tramplePos;
float width;
float height;

float dTime;

sampler2D Input;


[numthreads(8, 8, 1)]
void UpdatePhysics(uint3 id : SV_DispatchThreadID)
{
	// IDEA:	Use the structuredbuffer in the geometry shader for trample lookup. This will allow us to write negative numbers
	//			directly into the buffer and use them for trample offset (we can't use negative numbers in the result texture). 
	//			Create a separate kernel for the texture writing. This is purely for debug purposes. In that texture we can clamp the
	//			values to write actual color.


    // Get the distance to the tramplerpos. Invert (1 - ...) to get better numbers to work with.
    float dist = max(0, 1 - distance(float2(id.x / width, id.y / height), float2(tramplePos.x, tramplePos.z)));
	float distX = max(0, 1 - distance(id.x / width, tramplePos.x));
	float distZ = max(0, 1 - distance(id.y / height, tramplePos.z));

    // TODO: this needs to be separated in y and x component.
	float2 diffVector = float2(id.x / width, id.y / height) - float2(tramplePos.x, tramplePos.z);
    float lengthFactorX = smoothstep(0, trampleCutoff, abs(diffVector.x));
    float lengthFactorY = smoothstep(0, trampleCutoff, abs(diffVector.y));

    diffVector.x = lengthFactorX;
    diffVector.y = lengthFactorY;

    //diffVector.x = max(diffVector.x - (1.0 - trampleCutoff), 0) / trampleCutoff * lengthFactor;
    //diffVector.y = max(diffVector.y - (1.0 - trampleCutoff), 0) / trampleCutoff * lengthFactor;

    // Clamps the value to the cutoff distance. Linearly going from 0 -> 1 depeding on distance.
	float c = max(dist - (1.0 - trampleCutoff), 0) / trampleCutoff;
    float cX = max(distX - (1.0 - trampleCutoff), 0) / trampleCutoff * c * tramplePos.w; // tramplePos.z is velocity
	float cZ = max(distZ - (1.0 - trampleCutoff), 0) / trampleCutoff * c * tramplePos.w;

	// Get the current color from the buffer
	float4 currentColor = imgBuffer[width * id.x + id.y];

	// Update the value
	//currentColor = float4(min(currentColor.x + cX, 1.0) , min(currentColor.z + cZ, 1.0),  0 ,0); 
	//currentColor = float4(1 - abs(diffVector.x), 1 - abs(diffVector.y),  0 ,0); 
    currentColor = float4(1 - abs(diffVector.x), 1 - abs(diffVector.y), 0, 0);

	// Write the value to the result texture
	Result[id.xy] = currentColor;

	// Save it in the buffer again
	imgBuffer[width * id.x + id.y] = currentColor;



/*   psudo code for 2D -> 1D array indexing
	int array[width * height];

	 int SetElement(int row, int col, int value)
	 {
		array[width * row + col] = value;  
	 }
	 */
}

