// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpdatePhysics
#include "TexturePackingUtils.cginc"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWStructuredBuffer<float4> imgBuffer;

float trampleCutoff;
float4 tramplePos;
float2 moveDir;
float width;
float height;


const float PI = 3.14159265f;

[numthreads(8, 8, 1)]
void UpdatePhysics(uint3 id : SV_DispatchThreadID)
{
	// IDEA:	Use the structuredbuffer in the geometry shader for trample lookup. This will allow us to write negative numbers
	//			directly into the buffer and use them for trample offset (we can't use negative numbers in the result texture). 
	//			Create a separate kernel for the texture writing. This is purely for debug purposes. In that texture we can clamp the
	//			values to write actual color.

	// Get the current color from the buffer
	float4 currentColor = imgBuffer[width * id.x + id.y];
    
    // Vector from the trample point to the pixel.
    float2 diffVector = float2(tramplePos.x, tramplePos.z) - float2(id.x / width, id.y / height);

    // How much that vector is within the trample cutoff. 
    float dist = distance(float2(tramplePos.x, tramplePos.z), float2(id.x / width, id.y / height));
    

    float shouldBeTramepled = step(dist, trampleCutoff);
    float distanceFactor = 1 - lerp(0, trampleCutoff, dist);

    // Smoothed and cut off values from from the difftector
    //float xC = normalize(((float) sign(diffVector.x))) *  /*(1 - smoothstep(0, trampleCutoff, abs(diffVector.x))) **/ distanceFactor * (1.0 - abs(currentColor.x));
    //float yC = normalize(((float) sign(diffVector.y))) *  /*(1 - smoothstep(0, trampleCutoff, abs(diffVector.y))) **/ distanceFactor * (1.0 - abs(currentColor.y));
    
    float directionFactor = step(0, dot(normalize(diffVector), normalize(moveDir)));
    diffVector = normalize(diffVector);
    diffVector *= directionFactor;
    diffVector *= shouldBeTramepled;
    diffVector *= distanceFactor;

    //xC *= directionFactor;
    //yC *= directionFactor;

	// Update the value from the buffer
    currentColor = float4(clamp(currentColor.x + diffVector.x, -1, 1), clamp(currentColor.y + diffVector.y, -1, 1), 0, 0);
    currentColor.x /= 1.01;
    currentColor.y /= 1.01;

    // Pack the values and set them in the texture.
    float4 currentColorPacked = float4(PackFloat(currentColor.x), PackFloat(currentColor.y), 0, 0);

	// Write the value to the result texture
    Result[id.xy] = currentColorPacked;

	// Save it in the buffer again
    imgBuffer[width * id.x + id.y] = currentColor;



/*   psudo code for 2D -> 1D array indexing
	int array[width * height];

	 int SetElement(int row, int col, int value)
	 {
		array[width * row + col] = value;  
	 }
	 */
}

