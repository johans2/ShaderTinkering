// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpdatePhysics
#include "TexturePackingUtils.cginc"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWStructuredBuffer<float4> imgBuffer;

float trampleCutoff;
float2 tramplePos;
float2 moveDir;
float width;
float height;


const float PI = 3.14159265f;

[numthreads(8, 8, 1)]
void UpdatePhysics(uint3 id : SV_DispatchThreadID)
{
	// Get the current color from the buffer
	float4 currentColor = imgBuffer[width * id.x + id.y];
    
    // Vector from the trample point to the pixel.
    float2 diffVector = normalize(float2(tramplePos.x, tramplePos.y) - float2(id.x / width, id.y / height));

    // How much that vector is within the trample cutoff. 
    float dist = distance(float2(tramplePos.x, tramplePos.y), float2(id.x / width, id.y / height));
    
    float shouldBeTramepled = step(dist, trampleCutoff);
    float distanceFactor = 1 - lerp(0, trampleCutoff, dist);
    
    float directionFactor = step(0, dot(diffVector, normalize(moveDir)));
    diffVector *= directionFactor;
    diffVector *= shouldBeTramepled;
    diffVector *= distanceFactor;
    
	// Update the value from the buffer
    currentColor = float4(clamp(currentColor.x + diffVector.x, -1, 1), sin(clamp(currentColor.y - length(diffVector), -1, 1)), clamp(currentColor.z + diffVector.y, -1, 1), 0);
    currentColor /= 1.01;
    
    // Pack the values and set them in the texture.
    float4 currentColorPacked = float4(PackFloat(currentColor.x), PackFloat(currentColor.y), PackFloat(currentColor.z), 0);

	// Write the value to the result texture
    Result[id.xy] = currentColorPacked;

	// Save it in the buffer again
    imgBuffer[width * id.x + id.y] = currentColor;
    
}

