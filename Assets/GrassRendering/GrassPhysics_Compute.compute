// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpdatePhysics
#include "TexturePackingUtils.cginc"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWStructuredBuffer<float4> imgBuffer;

float trampleSmooth;
float trampleCutoff;
float4 tramplePos;
float width;
float height;

float dTime;

sampler2D Input;


[numthreads(8, 8, 1)]
void UpdatePhysics(uint3 id : SV_DispatchThreadID)
{
	// IDEA:	Use the structuredbuffer in the geometry shader for trample lookup. This will allow us to write negative numbers
	//			directly into the buffer and use them for trample offset (we can't use negative numbers in the result texture). 
	//			Create a separate kernel for the texture writing. This is purely for debug purposes. In that texture we can clamp the
	//			values to write actual color.
    
    // Vector from the trample point to the pixel.
    float2 diffVector = float2(tramplePos.x, tramplePos.z) - float2(id.x / width, id.y / height);

    // How much that vector is within the trample cutoff. Doesant work very well atm
    float dist = distance(float2(tramplePos.x, tramplePos.z), float2(id.x / width, id.y / height));
    float distanceFactor = abs((1 - dist) * (1 - smoothstep(0, trampleCutoff / 4.0, dist))); // why devide by 4 here?
    
    // Smoothed and cut off values from from the difftector
    float xC = ((float) sign(diffVector.x)) * (1 - smoothstep(0, trampleCutoff, abs(diffVector.x))) * distanceFactor;
    float yC = ((float) sign(diffVector.y)) * (1 - smoothstep(0, trampleCutoff, abs(diffVector.y))) * distanceFactor;
    
	// Get the current color from the buffer
	float4 currentColor = imgBuffer[width * id.x + id.y];

	// Update the value from the buffer
    currentColor = float4(clamp(currentColor.x + xC, -1, 1), clamp(currentColor.y + yC, -1, 1), 0, 0);
    currentColor.x /= 1.005;
    currentColor.y /= 1.005;

    // Pack the values and set them in the texture. TODO: Make pack/unpack a cging function.
    float xCPacked = (currentColor.x + 1.0) / 2;
    float yCPacked = (currentColor.y + 1.0) / 2;
    float4 currentColorPacked = float4(xCPacked, yCPacked, 0, 0);

	// Write the value to the result texture
    Result[id.xy] = currentColorPacked;

	// Save it in the buffer again
    imgBuffer[width * id.x + id.y] = currentColor;



/*   psudo code for 2D -> 1D array indexing
	int array[width * height];

	 int SetElement(int row, int col, int value)
	 {
		array[width * row + col] = value;  
	 }
	 */
}

