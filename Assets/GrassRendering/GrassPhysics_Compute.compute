// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel FlashInput
#pragma kernel UpdatePhysics

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
float trampleSmooth;
float trampleCutoff;
float4 tramplePos;
float width;
float height;

sampler2D Input;

[numthreads(8,8,1)]
void FlashInput(uint3 id : SV_DispatchThreadID)
{
	// Update the result texture based on the deformation pos.

	//Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
    Result[id.xy] = float4(1.0, 0.0, 0.0, 0.0);
}

[numthreads(8, 8, 1)]
void UpdatePhysics(uint3 id : SV_DispatchThreadID)
{
    
    // Get the distance to the tramplerpos. Invert (1 - ...) to get better numbers to work with.
    float dist = max(0, 1 - distance(float2(id.x / width, id.y / height), float2(tramplePos.x, tramplePos.z)));
    
    // Clamps the value to the cutoff distance. Linearly going from 0 -> 1 depeding on distance.
    float c = max(dist - (1.0 - trampleCutoff), 0) / trampleCutoff;
    
    float4 color = float4(c, c, 0, 0);
    
	Result[id.xy] = color;
}

uint RGBAtoUINT(float4 color)
{
    //uint4 bitShifts = uint4(24, 16, 8, 0);
    //uint4 colorAsBytes = uint4(color * 255.0f) << bitShifts;

    uint4 kEncodeMul = uint4(16777216, 65536, 256, 1);
    uint4 colorAsBytes = round(color * 255.0f);

    return dot(colorAsBytes, kEncodeMul);
}

float4 UINTtoRGBA(uint value)
{
    uint4 bitMask = uint4(0xff000000, 0x00ff0000, 0x0000ff00, 0x000000ff);
    uint4 bitShifts = uint4(24, 16, 8, 0);

    uint4 color = (uint4)value & bitMask;
    color >>= bitShifts;

    return color / 255.0f;
}